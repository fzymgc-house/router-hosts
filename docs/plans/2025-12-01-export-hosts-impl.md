# ExportHosts Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement the ExportHosts gRPC RPC to export host entries in hosts/json/csv formats.

**Architecture:** Create an export module with format helpers, update the bulk.rs handler to query hosts and stream formatted entries. Each entry streams as one message.

**Tech Stack:** Rust, tonic (gRPC), serde_json, DuckDB projections

---

## Task 1: Create Export Format Module with Hosts Format

**Files:**
- Create: `crates/router-hosts/src/server/export.rs`
- Modify: `crates/router-hosts/src/server/mod.rs` (add module)

**Step 1: Write failing test for hosts format**

In `crates/router-hosts/src/server/export.rs`:

```rust
//! Export format helpers for ExportHosts RPC

use crate::server::db::projections::HostEntry;

/// Supported export formats
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ExportFormat {
    Hosts,
    Json,
    Csv,
}

impl ExportFormat {
    /// Parse format string, returns None for invalid format
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "hosts" | "" => Some(Self::Hosts),
            "json" => Some(Self::Json),
            "csv" => Some(Self::Csv),
            _ => None,
        }
    }
}

/// Format a host entry for the hosts file format
pub fn format_hosts_entry(entry: &HostEntry) -> Vec<u8> {
    let mut line = format!("{}\t{}", entry.ip_address, entry.hostname);

    // Add comment if present
    let has_comment = entry.comment.as_ref().map(|c| !c.is_empty()).unwrap_or(false);
    let has_tags = !entry.tags.is_empty();

    if has_comment || has_tags {
        line.push_str("\t# ");
        if let Some(ref comment) = entry.comment {
            if !comment.is_empty() {
                line.push_str(comment);
            }
        }
        if has_tags {
            if has_comment && entry.comment.as_ref().map(|c| !c.is_empty()).unwrap_or(false) {
                line.push(' ');
            }
            line.push('[');
            line.push_str(&entry.tags.join(", "));
            line.push(']');
        }
    }
    line.push('\n');
    line.into_bytes()
}

/// Format header for hosts format
pub fn format_hosts_header(count: usize) -> Vec<u8> {
    let now = chrono::Utc::now();
    format!(
        "# Generated by router-hosts\n# Last updated: {}\n# Entry count: {}\n\n",
        now.format("%Y-%m-%d %H:%M:%S UTC"),
        count
    ).into_bytes()
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use ulid::Ulid;

    fn make_entry(ip: &str, hostname: &str, comment: Option<&str>, tags: Vec<&str>) -> HostEntry {
        HostEntry {
            id: Ulid::new(),
            ip_address: ip.to_string(),
            hostname: hostname.to_string(),
            comment: comment.map(|s| s.to_string()),
            tags: tags.into_iter().map(|s| s.to_string()).collect(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: 1,
        }
    }

    #[test]
    fn test_format_hosts_entry_simple() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10\tserver.local\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment() {
        let entry = make_entry("192.168.1.20", "nas.local", Some("NAS storage"), vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.20\tnas.local\t# NAS storage\n");
    }

    #[test]
    fn test_format_hosts_entry_with_tags() {
        let entry = make_entry("192.168.1.30", "iot.local", None, vec!["iot", "homelab"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.30\tiot.local\t# [iot, homelab]\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment_and_tags() {
        let entry = make_entry("192.168.1.40", "db.local", Some("Database"), vec!["prod"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.40\tdb.local\t# Database [prod]\n");
    }

    #[test]
    fn test_export_format_parsing() {
        assert_eq!(ExportFormat::from_str("hosts"), Some(ExportFormat::Hosts));
        assert_eq!(ExportFormat::from_str(""), Some(ExportFormat::Hosts));
        assert_eq!(ExportFormat::from_str("json"), Some(ExportFormat::Json));
        assert_eq!(ExportFormat::from_str("csv"), Some(ExportFormat::Csv));
        assert_eq!(ExportFormat::from_str("JSON"), Some(ExportFormat::Json));
        assert_eq!(ExportFormat::from_str("invalid"), None);
    }
}
```

**Step 2: Add module to server/mod.rs**

Add after existing modules:

```rust
pub mod export;
```

**Step 3: Run tests to verify they pass**

```bash
cargo test --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml -p router-hosts export -- --nocapture
```

Expected: All 5 tests pass

**Step 4: Commit**

```bash
git add crates/router-hosts/src/server/export.rs crates/router-hosts/src/server/mod.rs
git commit -m "feat(server): add export format helpers for hosts format"
```

---

## Task 2: Add JSON Format Support

**Files:**
- Modify: `crates/router-hosts/src/server/export.rs`

**Step 1: Add JSON format function and tests**

Add to `export.rs` after the hosts functions:

```rust
/// Format a host entry as JSON (one line, JSONL format)
pub fn format_json_entry(entry: &HostEntry) -> Vec<u8> {
    use serde_json::json;

    let obj = json!({
        "id": entry.id.to_string(),
        "ip_address": entry.ip_address,
        "hostname": entry.hostname,
        "comment": entry.comment,
        "tags": entry.tags,
        "created_at": entry.created_at.to_rfc3339(),
        "updated_at": entry.updated_at.to_rfc3339(),
        "version": entry.version.to_string(),
    });

    let mut bytes = serde_json::to_vec(&obj).unwrap();
    bytes.push(b'\n');
    bytes
}
```

Add tests:

```rust
    #[test]
    fn test_format_json_entry() {
        let entry = make_entry("192.168.1.10", "server.local", Some("Test"), vec!["tag1"]);
        let output = String::from_utf8(format_json_entry(&entry)).unwrap();

        // Parse back to verify it's valid JSON
        let parsed: serde_json::Value = serde_json::from_str(&output).unwrap();
        assert_eq!(parsed["ip_address"], "192.168.1.10");
        assert_eq!(parsed["hostname"], "server.local");
        assert_eq!(parsed["comment"], "Test");
        assert_eq!(parsed["tags"][0], "tag1");
    }

    #[test]
    fn test_format_json_entry_null_comment() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_json_entry(&entry)).unwrap();

        let parsed: serde_json::Value = serde_json::from_str(&output).unwrap();
        assert!(parsed["comment"].is_null());
    }
```

**Step 2: Run tests**

```bash
cargo test --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml -p router-hosts export -- --nocapture
```

Expected: All 7 tests pass

**Step 3: Commit**

```bash
git add crates/router-hosts/src/server/export.rs
git commit -m "feat(server): add JSON export format"
```

---

## Task 3: Add CSV Format Support

**Files:**
- Modify: `crates/router-hosts/src/server/export.rs`

**Step 1: Add CSV format functions and tests**

Add to `export.rs`:

```rust
/// Format CSV header row
pub fn format_csv_header() -> Vec<u8> {
    b"ip_address,hostname,comment,tags\n".to_vec()
}

/// Format a host entry as CSV
pub fn format_csv_entry(entry: &HostEntry) -> Vec<u8> {
    let comment = entry.comment.as_deref().unwrap_or("");
    let tags = entry.tags.join(";");

    // Quote fields that might contain commas or quotes
    let comment_escaped = escape_csv_field(comment);
    let tags_escaped = escape_csv_field(&tags);

    format!(
        "{},{},{},{}\n",
        entry.ip_address,
        entry.hostname,
        comment_escaped,
        tags_escaped
    ).into_bytes()
}

/// Escape a CSV field (quote if contains comma, quote, or newline)
fn escape_csv_field(s: &str) -> String {
    if s.contains(',') || s.contains('"') || s.contains('\n') {
        format!("\"{}\"", s.replace('"', "\"\""))
    } else {
        s.to_string()
    }
}
```

Add tests:

```rust
    #[test]
    fn test_format_csv_entry_simple() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,,\n");
    }

    #[test]
    fn test_format_csv_entry_with_tags() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec!["tag1", "tag2"]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,,tag1;tag2\n");
    }

    #[test]
    fn test_format_csv_entry_with_comma_in_comment() {
        let entry = make_entry("192.168.1.10", "server.local", Some("Hello, world"), vec![]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,\"Hello, world\",\n");
    }

    #[test]
    fn test_csv_header() {
        let header = String::from_utf8(format_csv_header()).unwrap();
        assert_eq!(header, "ip_address,hostname,comment,tags\n");
    }
```

**Step 2: Run tests**

```bash
cargo test --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml -p router-hosts export -- --nocapture
```

Expected: All 11 tests pass

**Step 3: Commit**

```bash
git add crates/router-hosts/src/server/export.rs
git commit -m "feat(server): add CSV export format"
```

---

## Task 4: Implement ExportHosts Handler

**Files:**
- Modify: `crates/router-hosts/src/server/service/bulk.rs`
- Modify: `crates/router-hosts/src/server/service/mod.rs`

**Step 1: Update bulk.rs with export implementation**

Replace the `handle_export_hosts` function in `bulk.rs`:

```rust
//! Import/Export operation handlers (streaming)

use crate::server::db::projections::HostProjections;
use crate::server::db::Database;
use crate::server::export::{
    format_csv_entry, format_csv_header, format_hosts_entry, format_hosts_header,
    format_json_entry, ExportFormat,
};
use crate::server::service::HostsServiceImpl;
use router_hosts_common::proto::{
    ExportHostsRequest, ExportHostsResponse, ImportHostsRequest, ImportHostsResponse,
};
use std::sync::Arc;
use tonic::{Request, Response, Status, Streaming};

impl HostsServiceImpl {
    /// Import hosts from file format via streaming
    ///
    /// Supports conflict handling modes via `conflict_mode` field:
    /// - "skip" (default): Skip entries that already exist (same IP+hostname)
    /// - "replace": Update existing entries with imported values
    /// - "strict": Fail if any duplicate is found
    ///
    /// Progress is reported via streaming ImportHostsResponse with counters:
    /// - processed: Total entries parsed from input
    /// - created: New entries added
    /// - skipped: Duplicates skipped (when conflict_mode = "skip")
    /// - failed: Validation failures
    pub async fn handle_import_hosts(
        &self,
        _request: Request<Streaming<ImportHostsRequest>>,
    ) -> Result<Response<Vec<ImportHostsResponse>>, Status> {
        // TODO: Implement streaming import
        Err(Status::unimplemented("ImportHosts not yet implemented"))
    }

    /// Export hosts in specified format via streaming
    ///
    /// Each host entry is sent as a separate response message.
    /// Format-specific headers (if any) are sent first.
    pub async fn handle_export_hosts(
        &self,
        request: Request<ExportHostsRequest>,
        db: Arc<Database>,
    ) -> Result<Response<Vec<ExportHostsResponse>>, Status> {
        let req = request.into_inner();

        // Parse and validate format
        let format = ExportFormat::from_str(&req.format).ok_or_else(|| {
            Status::invalid_argument(format!(
                "Invalid format '{}'. Supported: hosts, json, csv",
                req.format
            ))
        })?;

        // Query all hosts
        let entries = HostProjections::list_all(&db).map_err(|e| {
            Status::internal(format!("Failed to query hosts: {}", e))
        })?;

        let mut responses = Vec::new();

        // Send header if applicable
        match format {
            ExportFormat::Hosts => {
                responses.push(ExportHostsResponse {
                    chunk: format_hosts_header(entries.len()),
                });
            }
            ExportFormat::Csv => {
                responses.push(ExportHostsResponse {
                    chunk: format_csv_header(),
                });
            }
            ExportFormat::Json => {
                // No header for JSONL
            }
        }

        // Send each entry
        for entry in entries {
            let chunk = match format {
                ExportFormat::Hosts => format_hosts_entry(&entry),
                ExportFormat::Json => format_json_entry(&entry),
                ExportFormat::Csv => format_csv_entry(&entry),
            };
            responses.push(ExportHostsResponse { chunk });
        }

        Ok(Response::new(responses))
    }
}
```

**Step 2: Update service/mod.rs to call handler**

Replace the `export_hosts` function:

```rust
    async fn export_hosts(
        &self,
        request: Request<ExportHostsRequest>,
    ) -> Result<Response<Self::ExportHostsStream>, Status> {
        let responses = self.handle_export_hosts(request, Arc::clone(&self.db)).await?;
        let stream = futures::stream::iter(responses.into_inner().into_iter().map(Ok));
        Ok(Response::new(Box::pin(stream)))
    }
```

**Step 3: Run build to verify it compiles**

```bash
cargo build --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml -p router-hosts
```

Expected: Build succeeds

**Step 4: Commit**

```bash
git add crates/router-hosts/src/server/service/bulk.rs crates/router-hosts/src/server/service/mod.rs
git commit -m "feat(server): implement ExportHosts handler"
```

---

## Task 5: Add Integration Test for ExportHosts

**Files:**
- Modify: `crates/router-hosts/tests/integration_test.rs`

**Step 1: Add export integration test**

Add to `integration_test.rs`:

```rust
#[tokio::test]
async fn test_export_hosts_hosts_format() {
    let addr = start_test_server().await;
    let mut client = create_client(addr).await;

    // Add some hosts
    client
        .add_host(AddHostRequest {
            ip_address: "192.168.1.10".to_string(),
            hostname: "server.local".to_string(),
            comment: Some("Test server".to_string()),
            tags: vec!["test".to_string()],
        })
        .await
        .unwrap();

    client
        .add_host(AddHostRequest {
            ip_address: "192.168.1.20".to_string(),
            hostname: "nas.local".to_string(),
            comment: None,
            tags: vec![],
        })
        .await
        .unwrap();

    // Export as hosts format
    let mut stream = client
        .export_hosts(ExportHostsRequest {
            format: "hosts".to_string(),
        })
        .await
        .unwrap()
        .into_inner();

    let mut chunks = Vec::new();
    while let Some(response) = stream.message().await.unwrap() {
        chunks.push(response.chunk);
    }

    // First chunk should be header
    let header = String::from_utf8(chunks[0].clone()).unwrap();
    assert!(header.contains("Generated by router-hosts"));
    assert!(header.contains("Entry count: 2"));

    // Should have header + 2 entries = 3 chunks
    assert_eq!(chunks.len(), 3);
}

#[tokio::test]
async fn test_export_hosts_json_format() {
    let addr = start_test_server().await;
    let mut client = create_client(addr).await;

    // Add a host
    client
        .add_host(AddHostRequest {
            ip_address: "192.168.1.10".to_string(),
            hostname: "server.local".to_string(),
            comment: Some("Test".to_string()),
            tags: vec!["tag1".to_string()],
        })
        .await
        .unwrap();

    // Export as JSON
    let mut stream = client
        .export_hosts(ExportHostsRequest {
            format: "json".to_string(),
        })
        .await
        .unwrap()
        .into_inner();

    let mut chunks = Vec::new();
    while let Some(response) = stream.message().await.unwrap() {
        chunks.push(response.chunk);
    }

    // JSON has no header, just 1 entry
    assert_eq!(chunks.len(), 1);

    // Verify it's valid JSON
    let json_str = String::from_utf8(chunks[0].clone()).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();
    assert_eq!(parsed["ip_address"], "192.168.1.10");
    assert_eq!(parsed["hostname"], "server.local");
}

#[tokio::test]
async fn test_export_hosts_invalid_format() {
    let addr = start_test_server().await;
    let mut client = create_client(addr).await;

    let result = client
        .export_hosts(ExportHostsRequest {
            format: "invalid".to_string(),
        })
        .await;

    assert!(result.is_err());
    let status = result.unwrap_err();
    assert_eq!(status.code(), tonic::Code::InvalidArgument);
}
```

Add import at top of file:

```rust
use router_hosts_common::proto::ExportHostsRequest;
```

**Step 2: Run integration tests**

```bash
cargo test --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml --test integration_test export -- --nocapture
```

Expected: All 3 export tests pass

**Step 3: Run all tests**

```bash
cargo test --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml --workspace
```

Expected: All tests pass

**Step 4: Commit**

```bash
git add crates/router-hosts/tests/integration_test.rs
git commit -m "test: add integration tests for ExportHosts"
```

---

## Task 6: Final Verification and Cleanup

**Step 1: Run clippy**

```bash
cargo clippy --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml --workspace -- -D warnings
```

Expected: No warnings

**Step 2: Run fmt**

```bash
cargo fmt --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml --all
```

**Step 3: Run all tests one final time**

```bash
cargo test --manifest-path /Volumes/Code/github.com/fzymgc-house/router-hosts/.worktrees/feat/export-hosts/Cargo.toml --workspace
```

Expected: All tests pass

**Step 4: Push branch and create PR**

```bash
git push -u origin feat/export-hosts
gh pr create --title "feat(server): implement ExportHosts RPC" --body "$(cat <<'EOF'
## Summary

Implement the ExportHosts streaming RPC with support for hosts/json/csv formats.

## Changes

- Add `export.rs` module with format helpers
- Implement `handle_export_hosts` in bulk.rs
- Wire up the handler in service/mod.rs
- Add integration tests

## Formats

- **hosts**: Standard /etc/hosts format with header
- **json**: JSONL (one JSON object per line)
- **csv**: CSV with header row

## Test Plan

- [x] Unit tests for each format function
- [x] Integration tests for export via gRPC
- [x] Invalid format returns INVALID_ARGUMENT

Closes #10

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
```
