//! /etc/hosts file generation with atomic writes

use crate::server::db::{Database, DatabaseError, HostEntry, HostProjections};
use chrono::Utc;
use std::path::{Path, PathBuf};
use thiserror::Error;
use tokio::fs;
use tokio::io::AsyncWriteExt;

#[derive(Debug, Error)]
pub enum GenerateError {
    #[error("Database error: {0}")]
    Database(#[from] DatabaseError),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

pub type GenerateResult<T> = Result<T, GenerateError>;

pub struct HostsFileGenerator {
    path: PathBuf,
}

impl HostsFileGenerator {
    pub fn new(path: impl AsRef<Path>) -> Self {
        Self {
            path: path.as_ref().to_path_buf(),
        }
    }

    /// Regenerate /etc/hosts from current database state
    pub async fn regenerate(&self, db: &Database) -> GenerateResult<usize> {
        // Query all active hosts
        let entries = HostProjections::list_all(db)?;
        let count = entries.len();

        // Generate content
        let content = self.format_hosts_file(&entries);

        // Atomic write
        self.atomic_write(&content).await?;

        Ok(count)
    }

    /// Format entries as /etc/hosts content
    pub fn format_hosts_file(&self, entries: &[HostEntry]) -> String {
        let mut lines = Vec::new();

        // Header
        lines.push("# Generated by router-hosts".to_string());
        lines.push(format!(
            "# Last updated: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
        ));
        lines.push(format!("# Entry count: {}", entries.len()));
        lines.push(String::new());

        // Entries (already sorted by list_all)
        for entry in entries {
            let mut line = format!("{}\t{}", entry.ip_address, entry.hostname);

            // Add comment and tags
            let has_comment = entry.comment.is_some();
            let has_tags = !entry.tags.is_empty();

            if has_comment || has_tags {
                line.push_str("\t# ");
                if let Some(ref comment) = entry.comment {
                    line.push_str(comment);
                }
                if has_tags {
                    if has_comment {
                        line.push(' ');
                    }
                    line.push('[');
                    line.push_str(&entry.tags.join(", "));
                    line.push(']');
                }
            }

            lines.push(line);
        }

        lines.join("\n") + "\n"
    }

    /// Write content atomically: tmp file -> fsync -> rename
    ///
    /// On error, attempts to clean up the temporary file to avoid leaving
    /// stale .tmp files that could interfere with subsequent writes.
    async fn atomic_write(&self, content: &str) -> GenerateResult<()> {
        let tmp_path = self.path.with_extension("tmp");

        // Write to temp file
        let mut file = fs::File::create(&tmp_path).await?;

        // Use a cleanup helper on error
        let write_result = async {
            file.write_all(content.as_bytes()).await?;
            file.sync_all().await?;
            drop(file);
            Ok::<(), std::io::Error>(())
        }
        .await;

        if let Err(e) = write_result {
            // Best effort cleanup of temp file
            let _ = fs::remove_file(&tmp_path).await;
            return Err(e.into());
        }

        // Atomic rename
        if let Err(e) = fs::rename(&tmp_path, &self.path).await {
            // Best effort cleanup of temp file
            let _ = fs::remove_file(&tmp_path).await;
            return Err(e.into());
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_hosts_file_empty() {
        let gen = HostsFileGenerator::new("/tmp/hosts");
        let content = gen.format_hosts_file(&[]);

        assert!(content.contains("# Generated by router-hosts"));
        assert!(content.contains("# Entry count: 0"));
    }

    #[test]
    fn test_format_hosts_file_with_entries() {
        let gen = HostsFileGenerator::new("/tmp/hosts");
        let entries = vec![
            HostEntry {
                id: ulid::Ulid::new(),
                ip_address: "192.168.1.10".to_string(),
                hostname: "server.local".to_string(),
                comment: None,
                tags: vec![],
                created_at: Utc::now(),
                updated_at: Utc::now(),
                version: "01ARZ3NDEKTSV4RRFFQ69G5FAV".to_string(),
            },
            HostEntry {
                id: ulid::Ulid::new(),
                ip_address: "192.168.1.20".to_string(),
                hostname: "nas.local".to_string(),
                comment: Some("NAS storage".to_string()),
                tags: vec!["homelab".to_string()],
                created_at: Utc::now(),
                updated_at: Utc::now(),
                version: "01ARZ3NDEKTSV4RRFFQ69G5FAQ".to_string(),
            },
        ];

        let content = gen.format_hosts_file(&entries);

        assert!(content.contains("192.168.1.10\tserver.local"));
        assert!(content.contains("192.168.1.20\tnas.local\t# NAS storage [homelab]"));
    }

    #[tokio::test]
    async fn test_atomic_write() {
        let tmp_dir = std::env::temp_dir();
        let hosts_path = tmp_dir.join("test_hosts_atomic");

        let gen = HostsFileGenerator::new(&hosts_path);
        gen.atomic_write("test content\n").await.unwrap();

        let content = fs::read_to_string(&hosts_path).await.unwrap();
        assert_eq!(content, "test content\n");

        // Cleanup
        let _ = fs::remove_file(&hosts_path).await;
    }
}
