//! /etc/hosts file generation with atomic writes

use chrono::Utc;
use router_hosts_storage::{HostEntry, Storage, StorageError};
use std::path::{Path, PathBuf};
use thiserror::Error;
use tokio::fs;
use tokio::io::AsyncWriteExt;

#[derive(Debug, Error)]
pub enum GenerateError {
    #[error("Storage error: {0}")]
    Storage(#[from] StorageError),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

pub type GenerateResult<T> = Result<T, GenerateError>;

pub struct HostsFileGenerator {
    path: PathBuf,
}

impl HostsFileGenerator {
    pub fn new(path: impl AsRef<Path>) -> Self {
        Self {
            path: path.as_ref().to_path_buf(),
        }
    }

    /// Regenerate /etc/hosts from current storage state
    pub async fn regenerate(&self, storage: &dyn Storage) -> GenerateResult<usize> {
        // Query all active hosts
        let entries = storage.list_all().await?;
        let count = entries.len();

        // Generate content
        let content = self.format_hosts_file(&entries);

        // Atomic write
        self.atomic_write(&content).await?;

        Ok(count)
    }

    /// Format entries as /etc/hosts content
    pub fn format_hosts_file(&self, entries: &[HostEntry]) -> String {
        let mut lines = Vec::new();

        // Header
        lines.push("# Generated by router-hosts".to_string());
        lines.push(format!(
            "# Last updated: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
        ));
        lines.push(format!("# Entry count: {}", entries.len()));
        lines.push(String::new());

        // Entries (already sorted by list_all)
        for entry in entries {
            let mut line = format!("{}\t{}", entry.ip_address, entry.hostname);

            // Add comment and tags
            let has_comment = entry.comment.is_some();
            let has_tags = !entry.tags.is_empty();

            if has_comment || has_tags {
                line.push_str("\t# ");
                if let Some(ref comment) = entry.comment {
                    line.push_str(comment);
                }
                if has_tags {
                    if has_comment {
                        line.push(' ');
                    }
                    line.push('[');
                    line.push_str(&entry.tags.join(", "));
                    line.push(']');
                }
            }

            lines.push(line);
        }

        lines.join("\n") + "\n"
    }

    /// Write content atomically: tmp file -> fsync -> rename
    ///
    /// On error, attempts to clean up the temporary file to avoid leaving
    /// stale .tmp files that could interfere with subsequent writes.
    async fn atomic_write(&self, content: &str) -> GenerateResult<()> {
        let tmp_path = self.path.with_extension("tmp");

        // Write to temp file
        let mut file = fs::File::create(&tmp_path).await?;

        // Use a cleanup helper on error
        let write_result = async {
            file.write_all(content.as_bytes()).await?;
            file.sync_all().await?;
            drop(file);
            Ok::<(), std::io::Error>(())
        }
        .await;

        if let Err(e) = write_result {
            // Best effort cleanup of temp file
            let _ = fs::remove_file(&tmp_path).await;
            return Err(e.into());
        }

        // Atomic rename
        if let Err(e) = fs::rename(&tmp_path, &self.path).await {
            // Best effort cleanup of temp file
            let _ = fs::remove_file(&tmp_path).await;
            return Err(e.into());
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_hosts_file_empty() {
        let gen = HostsFileGenerator::new("/tmp/hosts");
        let content = gen.format_hosts_file(&[]);

        assert!(content.contains("# Generated by router-hosts"));
        assert!(content.contains("# Entry count: 0"));
    }

    #[test]
    fn test_format_hosts_file_with_entries() {
        let gen = HostsFileGenerator::new("/tmp/hosts");
        let entries = vec![
            HostEntry {
                id: ulid::Ulid::new(),
                ip_address: "192.168.1.10".to_string(),
                hostname: "server.local".to_string(),
                aliases: vec![],
                comment: None,
                tags: vec![],
                created_at: Utc::now(),
                updated_at: Utc::now(),
                version: "01ARZ3NDEKTSV4RRFFQ69G5FAV".to_string(),
            },
            HostEntry {
                id: ulid::Ulid::new(),
                ip_address: "192.168.1.20".to_string(),
                hostname: "nas.local".to_string(),
                aliases: vec![],
                comment: Some("NAS storage".to_string()),
                tags: vec!["homelab".to_string()],
                created_at: Utc::now(),
                updated_at: Utc::now(),
                version: "01ARZ3NDEKTSV4RRFFQ69G5FAQ".to_string(),
            },
        ];

        let content = gen.format_hosts_file(&entries);

        assert!(content.contains("192.168.1.10\tserver.local"));
        assert!(content.contains("192.168.1.20\tnas.local\t# NAS storage [homelab]"));
    }

    #[tokio::test]
    async fn test_atomic_write() {
        let tmp_dir = std::env::temp_dir();
        let hosts_path = tmp_dir.join("test_hosts_atomic");

        let gen = HostsFileGenerator::new(&hosts_path);
        gen.atomic_write("test content\n").await.unwrap();

        let content = fs::read_to_string(&hosts_path).await.unwrap();
        assert_eq!(content, "test content\n");

        // Cleanup
        let _ = fs::remove_file(&hosts_path).await;
    }

    /// Test that atomic write doesn't leave .tmp files after successful write
    #[tokio::test]
    async fn test_atomic_write_cleans_up_tmp_file() {
        let tmp_dir = std::env::temp_dir();
        let hosts_path = tmp_dir.join("test_hosts_atomic_cleanup");
        let tmp_path = hosts_path.with_extension("tmp");

        // Ensure clean state
        let _ = fs::remove_file(&hosts_path).await;
        let _ = fs::remove_file(&tmp_path).await;

        let gen = HostsFileGenerator::new(&hosts_path);
        gen.atomic_write("test content\n").await.unwrap();

        // Main file should exist
        assert!(
            fs::metadata(&hosts_path).await.is_ok(),
            "Main file should exist"
        );

        // Temp file should NOT exist after successful write
        assert!(
            fs::metadata(&tmp_path).await.is_err(),
            "Temp file should be cleaned up after successful write"
        );

        // Cleanup
        let _ = fs::remove_file(&hosts_path).await;
    }

    /// Test that atomic write overwrites existing file content completely
    #[tokio::test]
    async fn test_atomic_write_overwrites_existing() {
        let tmp_dir = std::env::temp_dir();
        let hosts_path = tmp_dir.join("test_hosts_atomic_overwrite");

        // Create initial file
        fs::write(&hosts_path, "old content\n").await.unwrap();

        let gen = HostsFileGenerator::new(&hosts_path);
        gen.atomic_write("new content\n").await.unwrap();

        let content = fs::read_to_string(&hosts_path).await.unwrap();
        assert_eq!(
            content, "new content\n",
            "Content should be completely replaced"
        );

        // Cleanup
        let _ = fs::remove_file(&hosts_path).await;
    }

    /// Test that multiple sequential writes work correctly
    #[tokio::test]
    async fn test_atomic_write_multiple_sequential() {
        let tmp_dir = std::env::temp_dir();
        let hosts_path = tmp_dir.join("test_hosts_atomic_seq");

        let gen = HostsFileGenerator::new(&hosts_path);

        // Multiple sequential writes
        for i in 1..=5 {
            let content = format!("content version {}\n", i);
            gen.atomic_write(&content).await.unwrap();

            let read_content = fs::read_to_string(&hosts_path).await.unwrap();
            assert_eq!(read_content, content, "Write {} should succeed", i);
        }

        // Cleanup
        let _ = fs::remove_file(&hosts_path).await;
    }

    /// Test atomic write with Unicode content
    #[tokio::test]
    async fn test_atomic_write_unicode() {
        let tmp_dir = std::env::temp_dir();
        let hosts_path = tmp_dir.join("test_hosts_atomic_unicode");

        let gen = HostsFileGenerator::new(&hosts_path);
        let content = "192.168.1.1\tserver.local\t# Êó•Êú¨Ë™û„Ç≥„É°„É≥„Éà üè†\n";
        gen.atomic_write(content).await.unwrap();

        let read_content = fs::read_to_string(&hosts_path).await.unwrap();
        assert_eq!(read_content, content);

        // Cleanup
        let _ = fs::remove_file(&hosts_path).await;
    }

    /// Test format_hosts_file with various tag and comment combinations
    #[test]
    fn test_format_hosts_file_metadata_combinations() {
        let gen = HostsFileGenerator::new("/tmp/hosts");

        // Entry with only tags (no comment)
        let entries_tags_only = vec![HostEntry {
            id: ulid::Ulid::new(),
            ip_address: "192.168.1.1".to_string(),
            hostname: "tagged.local".to_string(),
            aliases: vec![],
            comment: None,
            tags: vec!["prod".to_string(), "web".to_string()],
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: "01ARZ3NDEKTSV4RRFFQ69G5FAV".to_string(),
        }];

        let content = gen.format_hosts_file(&entries_tags_only);
        assert!(
            content.contains("192.168.1.1\ttagged.local\t# [prod, web]"),
            "Tags without comment should format as '# [tags]'"
        );

        // Entry with both comment and tags
        let entries_both = vec![HostEntry {
            id: ulid::Ulid::new(),
            ip_address: "192.168.1.2".to_string(),
            hostname: "both.local".to_string(),
            aliases: vec![],
            comment: Some("My server".to_string()),
            tags: vec!["dev".to_string()],
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: "01ARZ3NDEKTSV4RRFFQ69G5FAV".to_string(),
        }];

        let content = gen.format_hosts_file(&entries_both);
        assert!(
            content.contains("192.168.1.2\tboth.local\t# My server [dev]"),
            "Comment and tags should be separated by space"
        );

        // Entry with neither comment nor tags
        let entries_none = vec![HostEntry {
            id: ulid::Ulid::new(),
            ip_address: "192.168.1.3".to_string(),
            hostname: "plain.local".to_string(),
            aliases: vec![],
            comment: None,
            tags: vec![],
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: "01ARZ3NDEKTSV4RRFFQ69G5FAV".to_string(),
        }];

        let content = gen.format_hosts_file(&entries_none);
        assert!(
            content.contains("192.168.1.3\tplain.local\n")
                || content.ends_with("192.168.1.3\tplain.local\n"),
            "Entry without metadata should have no trailing comment"
        );
        assert!(
            !content.contains("192.168.1.3\tplain.local\t#"),
            "Entry without metadata should NOT have comment marker"
        );
    }
}
