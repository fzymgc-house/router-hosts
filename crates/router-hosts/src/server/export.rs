//! Export format helpers for ExportHosts RPC

use crate::server::db::HostEntry;

/// Supported export formats
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ExportFormat {
    Hosts,
    Json,
    Csv,
}

impl ExportFormat {
    /// Parse format string, returns None for invalid format
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "hosts" | "" => Some(Self::Hosts),
            "json" => Some(Self::Json),
            "csv" => Some(Self::Csv),
            _ => None,
        }
    }
}

/// Format a host entry for the hosts file format
pub fn format_hosts_entry(entry: &HostEntry) -> Vec<u8> {
    let mut line = format!("{}\t{}", entry.ip_address, entry.hostname);

    // Add comment if present
    let has_comment = entry.comment.as_ref().is_some_and(|c| !c.is_empty());
    let has_tags = !entry.tags.is_empty();

    if has_comment || has_tags {
        line.push_str("\t# ");
        if let Some(comment) = entry.comment.as_ref() {
            if !comment.is_empty() {
                line.push_str(comment);
            }
        }
        if has_tags {
            if has_comment && entry.comment.as_ref().is_some_and(|c| !c.is_empty()) {
                line.push(' ');
            }
            line.push('[');
            line.push_str(&entry.tags.join(", "));
            line.push(']');
        }
    }
    line.push('\n');
    line.into_bytes()
}

/// Format header for hosts format
pub fn format_hosts_header(count: usize) -> Vec<u8> {
    let now = chrono::Utc::now();
    format!(
        "# Generated by router-hosts\n# Last updated: {}\n# Entry count: {}\n\n",
        now.format("%Y-%m-%d %H:%M:%S UTC"),
        count
    )
    .into_bytes()
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use ulid::Ulid;

    fn make_entry(ip: &str, hostname: &str, comment: Option<&str>, tags: Vec<&str>) -> HostEntry {
        HostEntry {
            id: Ulid::new(),
            ip_address: ip.to_string(),
            hostname: hostname.to_string(),
            comment: comment.map(|s| s.to_string()),
            tags: tags.into_iter().map(|s| s.to_string()).collect(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: 1,
        }
    }

    #[test]
    fn test_format_hosts_entry_simple() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10\tserver.local\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment() {
        let entry = make_entry("192.168.1.20", "nas.local", Some("NAS storage"), vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.20\tnas.local\t# NAS storage\n");
    }

    #[test]
    fn test_format_hosts_entry_with_tags() {
        let entry = make_entry("192.168.1.30", "iot.local", None, vec!["iot", "homelab"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.30\tiot.local\t# [iot, homelab]\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment_and_tags() {
        let entry = make_entry("192.168.1.40", "db.local", Some("Database"), vec!["prod"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.40\tdb.local\t# Database [prod]\n");
    }

    #[test]
    fn test_export_format_parsing() {
        assert_eq!(ExportFormat::from_str("hosts"), Some(ExportFormat::Hosts));
        assert_eq!(ExportFormat::from_str(""), Some(ExportFormat::Hosts));
        assert_eq!(ExportFormat::from_str("json"), Some(ExportFormat::Json));
        assert_eq!(ExportFormat::from_str("csv"), Some(ExportFormat::Csv));
        assert_eq!(ExportFormat::from_str("JSON"), Some(ExportFormat::Json));
        assert_eq!(ExportFormat::from_str("invalid"), None);
    }
}
