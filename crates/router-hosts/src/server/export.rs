//! Export format helpers for ExportHosts RPC

use crate::server::db::HostEntry;

/// Supported export formats
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ExportFormat {
    Hosts,
    Json,
    Csv,
}

impl ExportFormat {
    /// Parse format string, returns None for invalid format
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "hosts" | "" => Some(Self::Hosts),
            "json" => Some(Self::Json),
            "csv" => Some(Self::Csv),
            _ => None,
        }
    }
}

/// Format a host entry for the hosts file format
pub fn format_hosts_entry(entry: &HostEntry) -> Vec<u8> {
    let mut line = format!("{}\t{}", entry.ip_address, entry.hostname);

    // Add comment if present
    let has_comment = entry.comment.as_ref().is_some_and(|c| !c.is_empty());
    let has_tags = !entry.tags.is_empty();

    if has_comment || has_tags {
        line.push_str("\t# ");
        if let Some(comment) = entry.comment.as_ref() {
            if !comment.is_empty() {
                line.push_str(comment);
            }
        }
        if has_tags {
            if has_comment && entry.comment.as_ref().is_some_and(|c| !c.is_empty()) {
                line.push(' ');
            }
            line.push('[');
            line.push_str(&entry.tags.join(", "));
            line.push(']');
        }
    }
    line.push('\n');
    line.into_bytes()
}

/// Format header for hosts format
pub fn format_hosts_header(count: usize) -> Vec<u8> {
    let now = chrono::Utc::now();
    format!(
        "# Generated by router-hosts\n# Last updated: {}\n# Entry count: {}\n\n",
        now.format("%Y-%m-%d %H:%M:%S UTC"),
        count
    )
    .into_bytes()
}

/// Format a host entry as JSON (one line, JSONL format)
pub fn format_json_entry(entry: &HostEntry) -> Vec<u8> {
    use serde_json::json;

    let obj = json!({
        "id": entry.id.to_string(),
        "ip_address": entry.ip_address,
        "hostname": entry.hostname,
        "comment": entry.comment,
        "tags": entry.tags,
        "created_at": entry.created_at.to_rfc3339(),
        "updated_at": entry.updated_at.to_rfc3339(),
        "version": entry.version.to_string(),
    });

    let mut bytes = serde_json::to_vec(&obj).expect("JSON serialization should not fail");
    bytes.push(b'\n');
    bytes
}

/// Format CSV header row
pub fn format_csv_header() -> Vec<u8> {
    b"ip_address,hostname,comment,tags\n".to_vec()
}

/// Format a host entry as CSV
pub fn format_csv_entry(entry: &HostEntry) -> Vec<u8> {
    let comment = entry.comment.as_deref().unwrap_or("");
    let tags = entry.tags.join(";");

    // Quote fields that might contain commas or quotes
    let comment_escaped = escape_csv_field(comment);
    let tags_escaped = escape_csv_field(&tags);

    format!(
        "{},{},{},{}\n",
        entry.ip_address, entry.hostname, comment_escaped, tags_escaped
    )
    .into_bytes()
}

/// Escape a CSV field (quote if contains comma, quote, or newline)
fn escape_csv_field(s: &str) -> String {
    if s.contains(',') || s.contains('"') || s.contains('\n') {
        format!("\"{}\"", s.replace('"', "\"\""))
    } else {
        s.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use ulid::Ulid;

    fn make_entry(ip: &str, hostname: &str, comment: Option<&str>, tags: Vec<&str>) -> HostEntry {
        HostEntry {
            id: Ulid::new(),
            ip_address: ip.to_string(),
            hostname: hostname.to_string(),
            comment: comment.map(|s| s.to_string()),
            tags: tags.into_iter().map(|s| s.to_string()).collect(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: 1,
        }
    }

    #[test]
    fn test_format_hosts_entry_simple() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10\tserver.local\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment() {
        let entry = make_entry("192.168.1.20", "nas.local", Some("NAS storage"), vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.20\tnas.local\t# NAS storage\n");
    }

    #[test]
    fn test_format_hosts_entry_with_tags() {
        let entry = make_entry("192.168.1.30", "iot.local", None, vec!["iot", "homelab"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.30\tiot.local\t# [iot, homelab]\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment_and_tags() {
        let entry = make_entry("192.168.1.40", "db.local", Some("Database"), vec!["prod"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.40\tdb.local\t# Database [prod]\n");
    }

    #[test]
    fn test_export_format_parsing() {
        assert_eq!(ExportFormat::from_str("hosts"), Some(ExportFormat::Hosts));
        assert_eq!(ExportFormat::from_str(""), Some(ExportFormat::Hosts));
        assert_eq!(ExportFormat::from_str("json"), Some(ExportFormat::Json));
        assert_eq!(ExportFormat::from_str("csv"), Some(ExportFormat::Csv));
        assert_eq!(ExportFormat::from_str("JSON"), Some(ExportFormat::Json));
        assert_eq!(ExportFormat::from_str("invalid"), None);
    }

    #[test]
    fn test_format_json_entry() {
        let entry = make_entry("192.168.1.10", "server.local", Some("Test"), vec!["tag1"]);
        let output = String::from_utf8(format_json_entry(&entry)).unwrap();

        // Parse back to verify it's valid JSON
        let parsed: serde_json::Value = serde_json::from_str(&output).unwrap();
        assert_eq!(parsed["ip_address"], "192.168.1.10");
        assert_eq!(parsed["hostname"], "server.local");
        assert_eq!(parsed["comment"], "Test");
        assert_eq!(parsed["tags"][0], "tag1");
    }

    #[test]
    fn test_format_json_entry_null_comment() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_json_entry(&entry)).unwrap();

        let parsed: serde_json::Value = serde_json::from_str(&output).unwrap();
        assert!(parsed["comment"].is_null());
    }

    #[test]
    fn test_format_csv_entry_simple() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,,\n");
    }

    #[test]
    fn test_format_csv_entry_with_tags() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec!["tag1", "tag2"]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,,tag1;tag2\n");
    }

    #[test]
    fn test_format_csv_entry_with_comma_in_comment() {
        let entry = make_entry("192.168.1.10", "server.local", Some("Hello, world"), vec![]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,\"Hello, world\",\n");
    }

    #[test]
    fn test_csv_header() {
        let header = String::from_utf8(format_csv_header()).unwrap();
        assert_eq!(header, "ip_address,hostname,comment,tags\n");
    }
}
