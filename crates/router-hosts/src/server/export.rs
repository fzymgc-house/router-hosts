//! Export format helpers for ExportHosts RPC

use crate::server::db::HostEntry;

/// Supported export formats
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ExportFormat {
    Hosts,
    Json,
    Csv,
}

/// Error type for invalid export format strings
#[derive(Debug, Clone, PartialEq)]
pub struct InvalidExportFormat;

impl std::fmt::Display for InvalidExportFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "invalid export format")
    }
}

impl std::str::FromStr for ExportFormat {
    type Err = InvalidExportFormat;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "hosts" | "" => Ok(Self::Hosts),
            "json" => Ok(Self::Json),
            "csv" => Ok(Self::Csv),
            _ => Err(InvalidExportFormat),
        }
    }
}

/// Format a host entry for the hosts file format
pub fn format_hosts_entry(entry: &HostEntry) -> Vec<u8> {
    let mut line = format!("{}\t{}", entry.ip_address, entry.hostname);

    // Add comment if present
    let has_comment = entry.comment.as_ref().is_some_and(|c| !c.is_empty());
    let has_tags = !entry.tags.is_empty();

    if has_comment || has_tags {
        line.push_str("\t# ");
        if let Some(comment) = &entry.comment {
            if !comment.is_empty() {
                line.push_str(comment);
                if has_tags {
                    line.push(' ');
                }
            }
        }
        if has_tags {
            line.push('[');
            line.push_str(&entry.tags.join(", "));
            line.push(']');
        }
    }
    line.push('\n');
    line.into_bytes()
}

/// Format header for hosts format
pub fn format_hosts_header(count: usize) -> Vec<u8> {
    let now = chrono::Utc::now();
    format!(
        "# Generated by router-hosts\n# Last updated: {}\n# Entry count: {}\n\n",
        now.format("%Y-%m-%d %H:%M:%S UTC"),
        count
    )
    .into_bytes()
}

/// Error type for export formatting failures
#[derive(Debug)]
pub struct ExportError(pub String);

impl std::fmt::Display for ExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "export error: {}", self.0)
    }
}

impl std::error::Error for ExportError {}

/// Format a host entry as JSON (one line, JSONL format)
pub fn format_json_entry(entry: &HostEntry) -> Result<Vec<u8>, ExportError> {
    use serde_json::json;

    let obj = json!({
        "id": entry.id.to_string(),
        "ip_address": entry.ip_address,
        "hostname": entry.hostname,
        "comment": entry.comment,
        "tags": entry.tags,
        "created_at": entry.created_at.to_rfc3339(),
        "updated_at": entry.updated_at.to_rfc3339(),
        "version": entry.version.to_string(),
    });

    let mut bytes = serde_json::to_vec(&obj)
        .map_err(|e| ExportError(format!("JSON serialization failed: {}", e)))?;
    bytes.push(b'\n');
    Ok(bytes)
}

/// Format CSV header row
pub fn format_csv_header() -> Vec<u8> {
    b"ip_address,hostname,comment,tags\n".to_vec()
}

/// Format a host entry as CSV
pub fn format_csv_entry(entry: &HostEntry) -> Vec<u8> {
    let comment = entry.comment.as_deref().unwrap_or("");
    let tags = entry.tags.join(";");

    // Escape all fields for defensive CSV formatting
    let ip_escaped = escape_csv_field(&entry.ip_address);
    let hostname_escaped = escape_csv_field(&entry.hostname);
    let comment_escaped = escape_csv_field(comment);
    let tags_escaped = escape_csv_field(&tags);

    format!(
        "{},{},{},{}\n",
        ip_escaped, hostname_escaped, comment_escaped, tags_escaped
    )
    .into_bytes()
}

/// Escape a CSV field (quote if contains comma, quote, or newline)
fn escape_csv_field(s: &str) -> String {
    if s.contains(',') || s.contains('"') || s.contains('\n') {
        format!("\"{}\"", s.replace('"', "\"\""))
    } else {
        s.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use ulid::Ulid;

    fn make_entry(ip: &str, hostname: &str, comment: Option<&str>, tags: Vec<&str>) -> HostEntry {
        HostEntry {
            id: Ulid::new(),
            ip_address: ip.to_string(),
            hostname: hostname.to_string(),
            comment: comment.map(|s| s.to_string()),
            tags: tags.into_iter().map(|s| s.to_string()).collect(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: "01ARZ3NDEKTSV4RRFFQ69G5FAV".to_string(),
        }
    }

    #[test]
    fn test_format_hosts_entry_simple() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10\tserver.local\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment() {
        let entry = make_entry("192.168.1.20", "nas.local", Some("NAS storage"), vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.20\tnas.local\t# NAS storage\n");
    }

    #[test]
    fn test_format_hosts_entry_with_tags() {
        let entry = make_entry("192.168.1.30", "iot.local", None, vec!["iot", "homelab"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.30\tiot.local\t# [iot, homelab]\n");
    }

    #[test]
    fn test_format_hosts_entry_with_comment_and_tags() {
        let entry = make_entry("192.168.1.40", "db.local", Some("Database"), vec!["prod"]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.40\tdb.local\t# Database [prod]\n");
    }

    #[test]
    fn test_export_format_parsing() {
        assert_eq!("hosts".parse::<ExportFormat>(), Ok(ExportFormat::Hosts));
        assert_eq!("".parse::<ExportFormat>(), Ok(ExportFormat::Hosts));
        assert_eq!("json".parse::<ExportFormat>(), Ok(ExportFormat::Json));
        assert_eq!("csv".parse::<ExportFormat>(), Ok(ExportFormat::Csv));
        assert_eq!("JSON".parse::<ExportFormat>(), Ok(ExportFormat::Json));
        assert!("invalid".parse::<ExportFormat>().is_err());
    }

    #[test]
    fn test_format_json_entry() {
        let entry = make_entry("192.168.1.10", "server.local", Some("Test"), vec!["tag1"]);
        let output = String::from_utf8(format_json_entry(&entry).unwrap()).unwrap();

        // Parse back to verify it's valid JSON
        let parsed: serde_json::Value = serde_json::from_str(&output).unwrap();
        assert_eq!(parsed["ip_address"], "192.168.1.10");
        assert_eq!(parsed["hostname"], "server.local");
        assert_eq!(parsed["comment"], "Test");
        assert_eq!(parsed["tags"][0], "tag1");
    }

    #[test]
    fn test_format_json_entry_null_comment() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_json_entry(&entry).unwrap()).unwrap();

        let parsed: serde_json::Value = serde_json::from_str(&output).unwrap();
        assert!(parsed["comment"].is_null());
    }

    #[test]
    fn test_format_csv_entry_simple() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec![]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,,\n");
    }

    #[test]
    fn test_format_csv_entry_with_tags() {
        let entry = make_entry("192.168.1.10", "server.local", None, vec!["tag1", "tag2"]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,,tag1;tag2\n");
    }

    #[test]
    fn test_format_csv_entry_with_comma_in_comment() {
        let entry = make_entry("192.168.1.10", "server.local", Some("Hello, world"), vec![]);
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10,server.local,\"Hello, world\",\n");
    }

    #[test]
    fn test_csv_header() {
        let header = String::from_utf8(format_csv_header()).unwrap();
        assert_eq!(header, "ip_address,hostname,comment,tags\n");
    }

    #[test]
    fn test_format_csv_entry_with_quotes_in_comment() {
        let entry = make_entry(
            "192.168.1.10",
            "server.local",
            Some("He said \"hello\""),
            vec![],
        );
        let output = String::from_utf8(format_csv_entry(&entry)).unwrap();
        // Quotes should be escaped by doubling them
        assert_eq!(
            output,
            "192.168.1.10,server.local,\"He said \"\"hello\"\"\",\n"
        );
    }

    #[test]
    fn test_format_hosts_entry_empty_comment() {
        // Empty string comment should not add comment marker
        let entry = make_entry("192.168.1.10", "server.local", Some(""), vec![]);
        let output = String::from_utf8(format_hosts_entry(&entry)).unwrap();
        assert_eq!(output, "192.168.1.10\tserver.local\n");
    }
}
